<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vanish - Global Video Platform</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1e1e2f 0%, #2a1e3c 100%);
      color: #d3c0f9;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .header {
      text-align: center;
      margin-bottom: 3rem;
      position: relative;
    }

    .creator-badge {
      position: absolute;
      top: -10px;
      right: 20px;
      font-size: 0.75rem;
      color: #a15fccaa;
      font-weight: 600;
      padding: 0.3rem 0.8rem;
      background: rgba(161, 95, 204, 0.1);
      border: 1px solid #a15fcc44;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    h1 {
      font-size: 3.5rem;
      margin: 0;
      background: linear-gradient(45deg, #a15fcc, #d3c0f9, #a15fcc);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-shift 3s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(161, 95, 204, 0.5);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .tagline {
      margin-top: 0.5rem;
      font-size: 1.1rem;
      opacity: 0.8;
      font-weight: 300;
    }

    .global-indicator {
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.3rem 0.8rem;
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      border-radius: 15px;
      color: #68d391;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .connection-status {
      display: inline-block;
      margin-left: 1rem;
      padding: 0.3rem 0.8rem;
      border-radius: 15px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .connection-status.connected {
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      color: #68d391;
    }

    .connection-status.disconnected {
      background: rgba(245, 101, 101, 0.2);
      border: 1px solid rgba(245, 101, 101, 0.4);
      color: #fc8181;
    }

    .upload-section {
      background: rgba(46, 46, 68, 0.6);
      border: 2px solid rgba(161, 95, 204, 0.3);
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 3rem;
      backdrop-filter: blur(15px);
      box-shadow: 0 8px 32px rgba(161, 95, 204, 0.1);
      transition: all 0.3s ease;
    }

    .upload-section:hover {
      border-color: rgba(161, 95, 204, 0.6);
      box-shadow: 0 12px 40px rgba(161, 95, 204, 0.2);
    }

    .input-group {
      margin-bottom: 1.5rem;
    }

    .input-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: #d3c0f9;
    }

    input[type="text"], input[type="file"] {
      width: 100%;
      font-size: 1rem;
      padding: 0.8rem 1rem;
      background: rgba(42, 30, 60, 0.8);
      color: #d3c0f9;
      border: 2px solid rgba(161, 95, 204, 0.4);
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus, input[type="file"]:focus {
      outline: none;
      border-color: #a15fcc;
      box-shadow: 0 0 0 3px rgba(161, 95, 204, 0.2);
    }

    .upload-btn {
      width: 100%;
      font-size: 1.1rem;
      font-weight: bold;
      padding: 1rem 2rem;
      background: linear-gradient(45deg, #a15fcc, #d3c0f9);
      color: #1e1e2f;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(161, 95, 204, 0.4);
    }

    .upload-btn:active {
      transform: translateY(0);
    }

    .upload-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .status {
      margin-top: 1rem;
      padding: 0.8rem;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .status.success {
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      color: #68d391;
    }

    .status.error {
      background: rgba(245, 101, 101, 0.2);
      border: 1px solid rgba(245, 101, 101, 0.4);
      color: #fc8181;
    }

    .status.loading {
      background: rgba(161, 95, 204, 0.2);
      border: 1px solid rgba(161, 95, 204, 0.4);
      color: #d3c0f9;
    }

    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }

    .video-card {
      background: rgba(46, 46, 68, 0.6);
      border: 2px solid rgba(161, 95, 204, 0.2);
      border-radius: 16px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      position: relative;
    }

    .video-card:hover {
      transform: translateY(-5px);
      border-color: rgba(161, 95, 204, 0.6);
      box-shadow: 0 15px 35px rgba(161, 95, 204, 0.2);
    }

    .video-thumbnail {
      width: 100%;
      height: 160px;
      object-fit: cover;
      background: linear-gradient(45deg, #2a1e3c, #1e1e2f);
    }

    .video-info {
      padding: 1rem;
    }

    .video-title {
      font-size: 1.1rem;
      font-weight: bold;
      margin: 0 0 0.5rem 0;
      color: #d3c0f9;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-meta {
      font-size: 0.85rem;
      color: #a15fccaa;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .global-badge {
      position: absolute;
      top: 0.5rem;
      left: 0.5rem;
      background: rgba(72, 187, 120, 0.8);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: bold;
    }

    .video-page {
      display: none;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .back-btn {
      background: rgba(161, 95, 204, 0.8);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .back-btn:hover {
      background: #a15fcc;
      transform: translateX(-3px);
    }

    .video-player-container {
      text-align: center;
      margin-bottom: 2rem;
    }

    .video-player {
      max-width: 100%;
      max-height: 70vh;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      background: #000;
    }

    .current-video-title {
      margin: 1rem 0;
      font-size: 1.8rem;
      font-weight: bold;
      color: #d3c0f9;
    }

    .empty-gallery {
      text-align: center;
      padding: 3rem;
      color: #a15fccaa;
      font-size: 1.1rem;
    }

    .upload-progress {
      width: 100%;
      height: 4px;
      background: rgba(161, 95, 204, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 1rem;
    }

    .upload-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #a15fcc, #d3c0f9);
      border-radius: 2px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .stats {
      text-align: center;
      margin-bottom: 2rem;
      padding: 1rem;
      background: rgba(46, 46, 68, 0.4);
      border-radius: 12px;
      border: 1px solid rgba(161, 95, 204, 0.2);
    }

    .stats-item {
      display: inline-block;
      margin: 0 1rem;
      color: #d3c0f9;
    }

    .stats-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #a15fcc;
    }

    .refresh-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: rgba(161, 95, 204, 0.9);
      color: white;
      border: none;
      padding: 0.8rem;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2rem;
      box-shadow: 0 4px 15px rgba(161, 95, 204, 0.3);
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .refresh-btn:hover {
      transform: scale(1.1) rotate(180deg);
      background: #a15fcc;
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem 0.5rem;
      }
      
      h1 {
        font-size: 2.5rem;
      }
      
      .gallery {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 1rem;
      }
      
      .creator-badge {
        position: static;
        display: inline-block;
        margin-top: 1rem;
      }

      .stats-item {
        display: block;
        margin: 0.5rem 0;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="creator-badge">Made By: U2FtIE0u</div>
      <h1>Vanish</h1>
      <p class="tagline">Global video platform - Share videos that vanish at midnight CST</p>
      <div class="global-indicator">üåç Global Platform Active</div>
      <div id="connectionStatus" class="connection-status disconnected">üî¥ Connecting to Firebase...</div>
    </div>

    <div class="stats" id="statsSection">
      <div class="stats-item">
        <div class="stats-value" id="totalVideos">0</div>
        <div>Total Videos</div>
      </div>
      <div class="stats-item">
        <div class="stats-value" id="onlineUsers">~</div>
        <div>Active Users</div>
      </div>
      <div class="stats-item">
        <div class="stats-value" id="timeToMidnight">--:--</div>
        <div>Until Reset</div>
      </div>
    </div>

    <div id="uploadSection" class="upload-section">
      <div class="input-group">
        <label for="titleInput">Video Title</label>
        <input type="text" id="titleInput" placeholder="Enter a catchy title for your video" autocomplete="off" maxlength="100" />
      </div>
      
      <div class="input-group">
        <label for="fileInput">Choose Video File (Max 5MB for global sharing)</label>
        <input type="file" id="fileInput" accept="video/*" />
      </div>
      
      <button id="uploadBtn" class="upload-btn" type="button">
        üåç Upload Video Globally
      </button>
      
      <div id="uploadProgress" class="upload-progress" style="display: none;">
        <div id="uploadProgressBar" class="upload-progress-bar"></div>
      </div>
      
      <div id="status" class="status" style="display: none;"></div>
    </div>

    <div id="gallery" class="gallery"></div>

    <div id="videoPage" class="video-page">
      <button id="backBtn" class="back-btn">‚Üê Back to Gallery</button>
      <div class="video-player-container">
        <h2 id="videoTitle" class="current-video-title"></h2>
        <video id="videoPlayer" class="video-player" controls preload="metadata"></video>
      </div>
    </div>
  </div>

  <button id="refreshBtn" class="refresh-btn" title="Refresh Videos">üîÑ</button>

  <!-- Firebase SDK -->
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, addDoc, getDocs, onSnapshot, query, orderBy, deleteDoc, doc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC9ck4UFiLC8JRyUHonTszDd38CWnbIEZs",
      authDomain: "vanish-22814.firebaseapp.com",
      projectId: "vanish-22814",
      storageBucket: "vanish-22814.firebasestorage.app",
      messagingSenderId: "631925934112",
      appId: "1:631925934112:web:fcd0dbe49dbeb6eee69445",
      measurementId: "G-MKTXH9N4XT"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    console.log('üöÄ Firebase initialized successfully!');

    class VanishGlobalPlatform {
      constructor() {
        console.log('üì± Initializing VanishGlobalPlatform with Firebase...');
        
        this.videos = [];
        this.db = db;
        this.isConnected = false;
        
        try {
          this.initializeElements();
          console.log('‚úÖ Elements initialized');
          
          this.initializeEventListeners();
          console.log('‚úÖ Event listeners initialized');
          
          this.initializeFirebase();
          console.log('‚úÖ Firebase connection started');
          
          this.startStatsUpdater();
          console.log('‚úÖ Stats updater started');
          
          this.startMidnightCleaner();
          console.log('‚úÖ Midnight cleaner started');
          
          console.log('üéâ Initialization complete!');
        } catch (error) {
          console.error('‚ùå Initialization failed:', error);
          this.updateConnectionStatus(false);
        }
      }

      initializeElements() {
        console.log('üîç Finding DOM elements...');
        
        this.uploadBtn = document.getElementById('uploadBtn');
        this.fileInput = document.getElementById('fileInput');
        this.status = document.getElementById('status');
        this.titleInput = document.getElementById('titleInput');
        this.gallery = document.getElementById('gallery');
        this.videoPage = document.getElementById('videoPage');
        this.videoPlayer = document.getElementById('videoPlayer');
        this.videoTitle = document.getElementById('videoTitle');
        this.backBtn = document.getElementById('backBtn');
        this.uploadSection = document.getElementById('uploadSection');
        this.uploadProgress = document.getElementById('uploadProgress');
        this.uploadProgressBar = document.getElementById('uploadProgressBar');
        this.refreshBtn = document.getElementById('refreshBtn');
        this.totalVideos = document.getElementById('totalVideos');
        this.onlineUsers = document.getElementById('onlineUsers');
        this.timeToMidnight = document.getElementById('timeToMidnight');
        this.connectionStatus = document.getElementById('connectionStatus');
      }

      initializeEventListeners() {
        console.log('üéØ Setting up event listeners...');
        
        if (this.uploadBtn) {
          this.uploadBtn.addEventListener('click', (event) => {
            console.log('üî• UPLOAD BUTTON CLICKED!');
            event.preventDefault();
            this.handleUpload();
          });
        }
        
        if (this.backBtn) {
          this.backBtn.addEventListener('click', () => {
            this.showGallery();
          });
        }
        
        if (this.refreshBtn) {
          this.refreshBtn.addEventListener('click', () => {
            this.loadVideosFromFirebase();
          });
        }
        
        if (this.fileInput) {
          this.fileInput.addEventListener('change', () => {
            this.validateFile();
            this.validateForm();
          });
        }
        
        if (this.titleInput) {
          this.titleInput.addEventListener('input', () => {
            this.validateForm();
          });
        }
      }

      async initializeFirebase() {
        try {
          console.log('üî• Connecting to Firebase...');
          
          // Test connection by getting videos
          await this.loadVideosFromFirebase();
          
          // Set up real-time listener
          this.setupRealtimeListener();
          
          this.updateConnectionStatus(true);
          console.log('‚úÖ Firebase connected successfully!');
          
        } catch (error) {
          console.error('‚ùå Firebase connection failed:', error);
          this.updateConnectionStatus(false);
          this.showStatus('Failed to connect to Firebase. Check your internet connection.', 'error');
        }
      }

      setupRealtimeListener() {
        console.log('üëÇ Setting up real-time listener...');
        
        const videosRef = collection(this.db, 'videos');
        const q = query(videosRef, orderBy('uploadTime', 'desc'));
        
        onSnapshot(q, (snapshot) => {
          console.log('üîÑ Real-time update received');
          this.videos = [];
          
          snapshot.forEach((doc) => {
            const data = doc.data();
            this.videos.push({
              id: doc.id,
              ...data
            });
          });
          
          this.renderGallery();
          console.log(`üìä Loaded ${this.videos.length} videos from Firebase`);
        }, (error) => {
          console.error('‚ùå Real-time listener error:', error);
          this.updateConnectionStatus(false);
        });
      }

      async loadVideosFromFirebase() {
        try {
          console.log('üì• Loading videos from Firebase...');
          
          const videosRef = collection(this.db, 'videos');
          const q = query(videosRef, orderBy('uploadTime', 'desc'));
          const querySnapshot = await getDocs(q);
          
          this.videos = [];
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            this.videos.push({
              id: doc.id,
              ...data
            });
          });
          
          this.renderGallery();
          console.log(`üìä Loaded ${this.videos.length} videos from Firebase`);
          
        } catch (error) {
          console.error('‚ùå Failed to load videos:', error);
          this.updateConnectionStatus(false);
          throw error;
        }
      }

      updateConnectionStatus(connected) {
        this.isConnected = connected;
        
        if (connected) {
          this.connectionStatus.className = 'connection-status connected';
          this.connectionStatus.textContent = 'üü¢ Connected to Firebase';
        } else {
          this.connectionStatus.className = 'connection-status disconnected';
          this.connectionStatus.textContent = 'üî¥ Firebase Disconnected';
        }
      }

      validateFile() {
        console.log('üîç Validating file...');
        const file = this.fileInput.files[0];
        if (!file) return false;

        console.log(`üìÑ File: ${file.name}, Size: ${file.size} bytes, Type: ${file.type}`);

        // 5MB limit for Firebase Firestore (document size limit is 1MB, but we can chunk if needed)
        if (file.size > 5 * 1024 * 1024) {
          this.showStatus('File too large! Maximum size is 5MB for global sharing.', 'error');
          this.fileInput.value = '';
          return false;
        }

        if (!file.type.startsWith('video/')) {
          this.showStatus('Please select a valid video file.', 'error');
          this.fileInput.value = '';
          return false;
        }

        this.hideStatus();
        return true;
      }

      validateForm() {
        const hasTitle = this.titleInput.value.trim().length > 0;
        const hasFile = this.fileInput.files.length > 0;
        const hasValidFile = hasFile && this.validateFile();
        
        this.uploadBtn.disabled = !hasTitle || !hasValidFile || !this.isConnected;
        return hasTitle && hasValidFile && this.isConnected;
      }

      async handleUpload() {
        console.log('üöÄ STARTING FIREBASE UPLOAD!');
        
        try {
          if (!this.isConnected) {
            this.showStatus('Not connected to Firebase. Please check your internet connection.', 'error');
            return;
          }

          if (!this.validateForm()) {
            this.showStatus('Please fill in all fields before uploading.', 'error');
            return;
          }

          const file = this.fileInput.files[0];
          const title = this.titleInput.value.trim();

          console.log(`üì§ Uploading to Firebase: "${title}" (${file.size} bytes)`);
          
          this.uploadBtn.disabled = true;
          this.showStatus('Converting video to base64...', 'loading');
          this.showProgress(10);

          // Convert video to base64
          const videoBase64 = await this.fileToBase64(file);
          this.showProgress(30);

          // Generate thumbnail
          this.showStatus('Generating thumbnail...', 'loading');
          const thumbnailData = await this.generateThumbnail(file);
          this.showProgress(50);

          // Check if we need to chunk the video data
          const videoId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
          const maxChunkSize = 800000; // 800KB to stay well under 1MB limit
          
          this.showStatus('Preparing video for upload...', 'loading');
          this.showProgress(60);

          if (videoBase64.length > maxChunkSize) {
            // Large video - chunk it
            console.log('üì¶ Video is large, chunking into multiple documents...');
            await this.uploadChunkedVideo(videoId, title, videoBase64, thumbnailData, file);
          } else {
            // Small video - upload normally
            console.log('üìÑ Video is small, uploading as single document...');
            await this.uploadSingleVideo(videoId, title, videoBase64, thumbnailData, file);
          }

          this.showProgress(100);
          
          // Clear form
          this.titleInput.value = '';
          this.fileInput.value = '';

          this.showStatus('üéâ Video uploaded globally! Everyone can see it now!', 'success');
          
          setTimeout(() => {
            this.hideStatus();
            this.hideProgress();
          }, 3000);

        } catch (error) {
          console.error('‚ùå Firebase upload failed:', error);
          
          if (error.code === 'failed-precondition' || error.message.includes('maximum allowed size')) {
            this.showStatus('Video too large for Firebase! Try a smaller file (under 3MB recommended).', 'error');
          } else if (error.code === 'permission-denied') {
            this.showStatus('Permission denied. Check Firebase security rules.', 'error');
          } else if (error.message.includes('longer than')) {
            this.showStatus('Video file too large. Please try a smaller video (under 2MB).', 'error');
          } else {
            this.showStatus(`Upload failed: ${error.message}`, 'error');
          }
        } finally {
          this.uploadBtn.disabled = false;
        }
      }

      async uploadSingleVideo(videoId, title, videoBase64, thumbnailData, file) {
        console.log('üìÑ Uploading single document...');
        
        const videoData = {
          id: videoId,
          title: title,
          videoData: videoBase64,
          thumbnail: thumbnailData,
          uploadTime: new Date().toISOString(),
          size: this.formatFileSize(file.size),
          uploader: this.generateAnonymousId(),
          fileName: file.name,
          fileType: file.type,
          location: this.getRandomLocation(),
          isChunked: false
        };

        this.showStatus('Uploading to Firebase...', 'loading');
        this.showProgress(90);

        await addDoc(collection(this.db, 'videos'), videoData);
        console.log('‚úÖ Single video uploaded to Firebase');
      }

      async uploadChunkedVideo(videoId, title, videoBase64, thumbnailData, file) {
        console.log('üì¶ Uploading chunked video...');
        
        const maxChunkSize = 800000; // 800KB chunks
        const chunks = [];
        
        // Split video data into chunks
        for (let i = 0; i < videoBase64.length; i += maxChunkSize) {
          chunks.push(videoBase64.slice(i, i + maxChunkSize));
        }
        
        console.log(`üì¶ Split video into ${chunks.length} chunks`);
        this.showStatus(`Uploading video in ${chunks.length} parts...`, 'loading');

        // Upload main video document (metadata only)
        const mainVideo = {
          id: videoId,
          title: title,
          thumbnail: thumbnailData,
          uploadTime: new Date().toISOString(),
          size: this.formatFileSize(file.size),
          uploader: this.generateAnonymousId(),
          fileName: file.name,
          fileType: file.type,
          location: this.getRandomLocation(),
          isChunked: true,
          totalChunks: chunks.length,
          videoData: '' // Empty for chunked videos
        };

        await addDoc(collection(this.db, 'videos'), mainVideo);
        
        // Upload chunks
        const chunkPromises = chunks.map((chunk, index) => {
          const chunkData = {
            videoId: videoId,
            chunkIndex: index,
            chunkData: chunk,
            uploadTime: new Date().toISOString()
          };
          return addDoc(collection(this.db, 'video_chunks'), chunkData);
        });

        this.showProgress(80);
        await Promise.all(chunkPromises);
        
        console.log(`‚úÖ Chunked video uploaded: ${chunks.length} chunks`);
      }

      async fileToBase64(file) {
        console.log('üîÑ Converting file to base64...');
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = e => resolve(e.target.result);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      async generateThumbnail(file) {
        console.log('üñºÔ∏è Generating thumbnail...');
        return new Promise((resolve, reject) => {
          const video = document.createElement('video');
          const url = URL.createObjectURL(file);
          video.src = url;
          video.crossOrigin = 'anonymous';
          video.muted = true;
          video.preload = 'metadata';

          video.addEventListener('loadedmetadata', () => {
            video.currentTime = Math.min(video.duration * 0.25, 5);
          });

          video.addEventListener('seeked', () => {
            try {
              const canvas = document.createElement('canvas');
              const aspectRatio = video.videoWidth / video.videoHeight;
              
              canvas.width = 320;
              canvas.height = 320 / aspectRatio;
              
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              
              URL.revokeObjectURL(url);
              resolve(canvas.toDataURL('image/jpeg', 0.7));
            } catch (error) {
              URL.revokeObjectURL(url);
              resolve(this.generateDefaultThumbnail());
            }
          });

          video.addEventListener('error', () => {
            URL.revokeObjectURL(url);
            resolve(this.generateDefaultThumbnail());
          });
        });
      }

      generateDefaultThumbnail() {
        const canvas = document.createElement('canvas');
        canvas.width = 320;
        canvas.height = 180;
        const ctx = canvas.getContext('2d');
        
        const gradient = ctx.createLinearGradient(0, 0, 320, 180);
        gradient.addColorStop(0, '#2a1e3c');
        gradient.addColorStop(1, '#1e1e2f');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 320, 180);
        
        ctx.fillStyle = '#a15fcc';
        ctx.beginPath();
        ctx.moveTo(120, 60);
        ctx.lineTo(180, 90);
        ctx.lineTo(120, 120);
        ctx.closePath();
        ctx.fill();
        
        return canvas.toDataURL('image/jpeg', 0.7);
      }

      renderGallery() {
        if (this.videos.length === 0) {
          this.gallery.innerHTML = `
            <div class="empty-gallery">
              <p>üìπ No videos uploaded yet.</p>
              <p>Be the first to share a video globally!</p>
            </div>
          `;
          this.totalVideos.textContent = '0';
          return;
        }

        this.gallery.innerHTML = this.videos.map((video, index) => `
          <div class="video-card" onclick="vanishApp.showVideo(${index})" data-index="${index}">
            <div class="global-badge">GLOBAL</div>
            <img src="${video.thumbnail}" alt="${video.title}" class="video-thumbnail" loading="lazy" />
            <div class="video-info">
              <h3 class="video-title">${this.escapeHtml(video.title)}</h3>
              <div class="video-meta">
                <span>${this.timeAgo(video.uploadTime)}</span>
                <span>${video.size}</span>
              </div>
              <div class="video-meta">
                <span>üìç ${video.location || 'Unknown'}</span>
                <span>üë§ ${video.uploader}</span>
              </div>
            </div>
          </div>
        `).join('');

        this.totalVideos.textContent = this.videos.length;
        console.log(`‚úÖ Gallery rendered with ${this.videos.length} videos`);
      }

      showVideo(index) {
        console.log(`üì∫ Showing video ${index}`);
        const video = this.videos[index];
        if (!video) return;

        this.videoTitle.textContent = video.title;
        this.videoPlayer.src = video.videoData; // Use base64 data directly
        this.videoPlayer.load();
        
        this.gallery.style.display = 'none';
        this.uploadSection.style.display = 'none';
        this.videoPage.style.display = 'block';
        
        setTimeout(() => {
          this.videoPlayer.play().catch(e => {
            console.log('Auto-play prevented by browser policy');
          });
        }, 100);
      }

      showGallery() {
        console.log('üè† Showing gallery');
        this.videoPlayer.pause();
        this.videoPlayer.src = '';
        
        this.videoPage.style.display = 'none';
        this.gallery.style.display = 'grid';
        this.uploadSection.style.display = 'block';
        
        this.hideStatus();
      }

      startStatsUpdater() {
        this.updateStats();
        setInterval(() => this.updateStats(), 30000);
      }

      updateStats() {
        // Simulate online users (you could make this real by tracking active connections)
        this.onlineUsers.textContent = Math.floor(Math.random() * 50) + 10;
        
        // Calculate time until midnight CST
        const now = new Date();
        const cstOffset = -6 * 60; // CST is UTC-6
        const nowCST = new Date(now.getTime() + (now.getTimezoneOffset() + cstOffset) * 60 * 1000);
        
        const tomorrow = new Date(nowCST);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);
        
        const timeUntilMidnight = tomorrow - nowCST;
        const hours = Math.floor(timeUntilMidnight / (1000 * 60 * 60));
        const minutes = Math.floor((timeUntilMidnight % (1000 * 60 * 60)) / (1000 * 60));
        
        this.timeToMidnight.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }

      startMidnightCleaner() {
        console.log('üïõ Starting midnight cleaner...');
        
        // Check every minute if it's midnight CST
        setInterval(async () => {
          const now = new Date();
          const cstOffset = -6 * 60; // CST is UTC-6
          const nowCST = new Date(now.getTime() + (now.getTimezoneOffset() + cstOffset) * 60 * 1000);
          
          // Check if it's midnight CST (00:00)
          if (nowCST.getHours() === 0 && nowCST.getMinutes() === 0) {
            console.log('üïõ MIDNIGHT CST! Deleting all videos...');
            await this.deleteAllVideos();
          }
        }, 60000); // Check every minute
      }

      async deleteAllVideos() {
        try {
          console.log('üóëÔ∏è Deleting all videos from Firebase...');
          this.showStatus('üïõ Midnight reset! Deleting all videos...', 'loading');
          
          const videosRef = collection(this.db, 'videos');
          const snapshot = await getDocs(videosRef);
          
          const deletePromises = [];
          snapshot.forEach((doc) => {
            deletePromises.push(deleteDoc(doc.ref));
          });
          
          await Promise.all(deletePromises);
          
          console.log('‚úÖ All videos deleted successfully!');
          this.showStatus('üåÖ Fresh start! All videos have been deleted at midnight CST.', 'success');
          
          setTimeout(() => {
            this.hideStatus();
          }, 5000);
          
        } catch (error) {
          console.error('‚ùå Failed to delete videos:', error);
          this.showStatus('Failed to delete videos. Please refresh the page.', 'error');
        }
      }

      generateAnonymousId() {
        return 'anon_' + Math.random().toString(36).substr(2, 6);
      }

      getRandomLocation() {
        const locations = [
          'New York, US', 'London, UK', 'Tokyo, JP', 'Paris, FR', 'Sydney, AU',
          'Berlin, DE', 'Toronto, CA', 'Seoul, KR', 'Mumbai, IN', 'S√£o Paulo, BR',
          'Mexico City, MX', 'Cairo, EG', 'Lagos, NG', 'Bangkok, TH', 'Moscow, RU',
          'Buenos Aires, AR', 'Istanbul, TR', 'Jakarta, ID', 'Manila, PH', 'Nairobi, KE'
        ];
        return locations[Math.floor(Math.random() * locations.length)];
      }

      showStatus(message, type) {
        this.status.textContent = message;
        this.status.className = `status ${type}`;
        this.status.style.display = 'block';
      }

      hideStatus() {
        this.status.style.display = 'none';
      }

      showProgress(percent) {
        this.uploadProgress.style.display = 'block';
        this.uploadProgressBar.style.width = percent + '%';
      }

      hideProgress() {
        this.uploadProgress.style.display = 'none';
        this.uploadProgressBar.style.width = '0%';
      }

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      timeAgo(dateString) {
        const now = new Date();
        const past = new Date(dateString);
        const diffInMinutes = Math.floor((now - past) / (1000 * 60));
        
        if (diffInMinutes < 1) return 'Just now';
        if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
        if (diffInMinutes < 1440) return `${Math.floor(diffInMinutes / 60)}h ago`;
        return `${Math.floor(diffInMinutes / 1440)}d ago`;
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    }

    // Initialize the app and make it globally accessible
    window.vanishApp = new VanishGlobalPlatform();
  </script>
</body>
</html>
