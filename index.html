<!DOCTYPE html> 
<html lang="en"><head>
  <meta charset="UTF-8">
  <title>Vanish - Global Video Platform</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1e1e2f 0%, #2a1e3c 100%);
      color: #d3c0f9;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    .header {
      text-align: center;
      margin-bottom: 3rem;
      position: relative;
    }

    .creator-badge {
      position: absolute;
      top: -10px;
      right: 20px;
      font-size: 0.75rem;
      color: #a15fccaa;
      font-weight: 600;
      padding: 0.3rem 0.8rem;
      background: rgba(161, 95, 204, 0.1);
      border: 1px solid #a15fcc44;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    h1 {
      font-size: 3.5rem;
      margin: 0;
      background: linear-gradient(45deg, #a15fcc, #d3c0f9, #a15fcc);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient-shift 3s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(161, 95, 204, 0.5);
    }

    @keyframes gradient-shift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .tagline {
      margin-top: 0.5rem;
      font-size: 1.1rem;
      opacity: 0.8;
      font-weight: 300;
    }

    .global-indicator {
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.3rem 0.8rem;
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      border-radius: 15px;
      color: #68d391;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .connection-status {
      display: inline-block;
      margin-left: 1rem;
      padding: 0.3rem 0.8rem;
      border-radius: 15px;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .connection-status.connected {
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      color: #68d391;
    }

    .connection-status.disconnected {
      background: rgba(245, 101, 101, 0.2);
      border: 1px solid rgba(245, 101, 101, 0.4);
      color: #fc8181;
    }

    .security-indicator {
      display: inline-block;
      margin-left: 1rem;
      padding: 0.3rem 0.8rem;
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      border-radius: 15px;
      color: #d3c0f9;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .upload-section {
      background: rgba(46, 46, 68, 0.6);
      border: 2px solid rgba(161, 95, 204, 0.3);
      border-radius: 20px;
      padding: 2rem;
      margin-bottom: 3rem;
      backdrop-filter: blur(15px);
      box-shadow: 0 8px 32px rgba(161, 95, 204, 0.1);
      transition: all 0.3s ease;
    }

    .upload-section:hover {
      border-color: rgba(161, 95, 204, 0.6);
      box-shadow: 0 12px 40px rgba(161, 95, 204, 0.2);
    }

    .input-group {
      margin-bottom: 1.5rem;
    }

    .input-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: #d3c0f9;
    }

    input[type="text"], input[type="file"] {
      width: 100%;
      font-size: 1rem;
      padding: 0.8rem 1rem;
      background: rgba(42, 30, 60, 0.8);
      color: #d3c0f9;
      border: 2px solid rgba(161, 95, 204, 0.4);
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus, input[type="file"]:focus {
      outline: none;
      border-color: #a15fcc;
      box-shadow: 0 0 0 3px rgba(161, 95, 204, 0.2);
    }

    .compression-options {
      background: rgba(42, 30, 60, 0.4);
      border: 1px solid rgba(161, 95, 204, 0.3);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }

    .compression-options h4 {
      margin: 0 0 0.5rem 0;
      color: #a15fcc;
      font-size: 0.9rem;
    }

    .quality-slider {
      width: 100%;
      margin: 0.5rem 0;
    }

    .quality-info {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: #a15fccaa;
    }

    .upload-btn {
      width: 100%;
      font-size: 1.1rem;
      font-weight: bold;
      padding: 1rem 2rem;
      background: linear-gradient(45deg, #a15fcc, #d3c0f9);
      color: #1e1e2f;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
        .countdown-timer {
      margin-top: 0.8rem;
      text-align: center;
      font-size: 1rem;
      font-weight: 500;
      color: #a15fcc;
      background: rgba(161, 95, 204, 0.15);
      border: 1px solid rgba(161, 95, 204, 0.3);
      border-radius: 10px;
      padding: 0.6rem 1rem;
      display: inline-block;
      box-shadow: 0 4px 12px rgba(161, 95, 204, 0.2);
      animation: fadeIn 0.5s ease;
    }


    .upload-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(161, 95, 204, 0.4);
    }

    .upload-btn:active {
      transform: translateY(0);
    }

    .upload-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
        .upload-progress {
      width: 100%;
      height: 6px;
      background: rgba(161, 95, 204, 0.2);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 1rem;
    }
    
    .upload-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #a15fcc, #d3c0f9);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .countdown-timer {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #d3c0f9;
      font-weight: 600;
    }


    .status {
      margin-top: 1rem;
      padding: 0.8rem;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .status.success {
      background: rgba(72, 187, 120, 0.2);
      border: 1px solid rgba(72, 187, 120, 0.4);
      color: #68d391;
    }

    .status.error {
      background: rgba(245, 101, 101, 0.2);
      border: 1px solid rgba(245, 101, 101, 0.4);
      color: #fc8181;
    }

    .status.loading {
      background: rgba(161, 95, 204, 0.2);
      border: 1px solid rgba(161, 95, 204, 0.4);
      color: #d3c0f9;
    }

    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }

    .video-card {
      background: rgba(46, 46, 68, 0.6);
      border: 2px solid rgba(161, 95, 204, 0.2);
      border-radius: 16px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      position: relative;
    }

    .video-card:hover {
      transform: translateY(-5px);
      border-color: rgba(161, 95, 204, 0.6);
      box-shadow: 0 15px 35px rgba(161, 95, 204, 0.2);
    }

    .video-thumbnail {
      width: 100%;
      height: 160px;
      object-fit: cover;
      background: linear-gradient(45deg, #2a1e3c, #1e1e2f);
    }

    .video-info {
      padding: 1rem;
    }

    .video-title {
      font-size: 1.1rem;
      font-weight: bold;
      margin: 0 0 0.5rem 0;
      color: #d3c0f9;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .video-meta {
      font-size: 0.85rem;
      color: #a15fccaa;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .global-badge {
      position: absolute;
      top: 0.5rem;
      left: 0.5rem;
      background: rgba(72, 187, 120, 0.8);
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      font-size: 0.7rem;
      font-weight: bold;
    }

    .video-page {
      display: none;
      animation: fadeIn 0.5s ease;
    }
    
    .back-btn {
      display: block;           /* make it take the full line */
      margin: 0 auto 2rem auto; /* center horizontally, add bottom margin */
      background: linear-gradient(45deg, #a15fcc, #d3c0f9);
      color: #1e1e2f;
      border: none;
      border-radius: 12px;
      padding: 0.8rem 1.5rem;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(161, 95, 204, 0.4);
      transition: all 0.3s ease;
      user-select: none;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    . {
      background: rgba(161, 95, 204, 0.8);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 10px;
      font-weight: bold;
      cursor: pointer;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .:hover {
      background: #a15fcc;
      transform: translateX(-3px);
    }

    .video-player-container {
      text-align: center;
      margin-bottom: 2rem;
    }
Z
    .video-player {
      max-width: 100%;
      max-height: 70vh;
      border-radius: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      background: #000;
    }

    .current-video-title {
      margin: 1rem 0;
      font-size: 1.8rem;
      font-weight: bold;
      color: #d3c0f9;
    }

    .empty-gallery {
      text-align: center;
      padding: 3rem;
      color: #a15fccaa;
      font-size: 1.1rem;
    }

    .upload-progress {
      width: 100%;
      height: 4px;
      background: rgba(161, 95, 204, 0.2);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 1rem;
    }

    .upload-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #a15fcc, #d3c0f9);
      border-radius: 2px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .stats {
      text-align: center;
      margin-bottom: 2rem;
      padding: 1rem;
      background: rgba(46, 46, 68, 0.4);
      border-radius: 12px;
      border: 1px solid rgba(161, 95, 204, 0.2);
    }

    .stats-item {
      display: inline-block;
      margin: 0 1rem;
      color: #d3c0f9;
    }

    .stats-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #a15fcc;
    }

    .refresh-btn {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: rgba(161, 95, 204, 0.9);
      color: white;
      border: none;
      padding: 0.8rem;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2rem;
      box-shadow: 0 4px 15px rgba(161, 95, 204, 0.3);
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .refresh-btn:hover {
      transform: scale(1.1) rotate(180deg);
      background: #a15fcc;
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem 0.5rem;
      }
      
      h1 {
        font-size: 2.5rem;
      }
      
      .gallery {
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 1rem;
      }
      
      .creator-badge {
        position: static;
        display: inline-block;
        margin-top: 1rem;
      }

      .stats-item {
        display: block;
        margin: 0.5rem 0;
        
        
        
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="creator-badge">Made By: U2FtIE0u</div>
      <h1>Vanish</h1>
      <p class="tagline"><em>Because forever is boring.</em></p>
      <div class="global-indicator">üåç Platform Active</div>
      <div id="connectionStatus" class="connection-status connected">üü¢ Connected to Servers</div>
      <div id="securityStatus" class="security-indicator" style="color: rgb(104, 211, 145);">üü¢ Secured</div>
    </div>

    <div class="stats" id="statsSection">
      <div class="stats-item">
        <div class="stats-value" id="totalVideos">3</div>
        <div>Total Videos</div>
      </div>
      <div class="stats-item">
        <div class="stats-value" id="onlineUsers">0</div>
        <div>Active Users</div>
      </div>
      <div class="stats-item">
        <div class="stats-value" id="timeToMidnight">01:17</div>
        <div>Until Reset</div>
      </div>
    </div>

    <div id="uploadSection" class="upload-section" style="display: block;">
      <div class="input-group">
        <label for="titleInput">Video Title</label>
        <input type="text" id="titleInput" placeholder="Enter a title for your video" autocomplete="off" maxlength="100">
      </div>
      
      <div class="input-group">
        <label for="fileInput">Choose Video File</label>
        <input type="file" id="fileInput" accept="video/*">
        
        <div class="compression-options" id="compressionOptions" style="display: none;">
          <h4>üóúÔ∏è Auto-Compression Settings</h4>
          <div>
            <label for="qualitySlider">Quality Level:</label>
            <input type="range" id="qualitySlider" class="quality-slider" min="0.3" max="0.9" step="0.1" value="0.7">
            <div class="quality-info">
              <span>Lower Quality (Smaller File)</span>
              <span id="qualityValue">0.7</span>
              <span>Higher Quality (Larger File)</span>
            </div>
          </div>
          <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #a15fccaa;">
            Auto-compression will reduce file size to fit Firebase limits while maintaining playback quality.
          </div>
        </div>
      </div>
      
      <button id="uploadBtn" class="upload-btn" type="button" disabled="">
        üåç Upload Video
      </button>
      
     <div id="countdown" class="countdown-timer" style="display:none;">
      Estimated time left: <span id="countdownValue">00:00</span>
    </div>
    
    <div id="uploadProgress" class="upload-progress" style="display:none;">
        <div class="upload-progress-bar"></div>
    </div>


      
    <div id="countdown" class="countdown-timer" style="display:none;">
      Estimated time left: <span id="countdownValue">00:00</span>
    </div>
          
      <div id="status" class="status loading" style="display: none;">Loading video...</div>
    </div>

    <div id="gallery" class="gallery" style="display: grid;">
          
              </div>
            </div>

    <div id="videoPage" class="video-page" style="display: none;">
      <button id="backBtn" class="back-btn">‚Üê Back to Videos</button>
      <div class="video-player-container">
        <h2 id="videoTitle" class="current-video-title">comp test</h2>
        <video id="videoPlayer" class="video-player" controls="" preload="metadata" src=""></video>
      </div>
    </div>

  <button id="refreshBtn" class="refresh-btn" title="Refresh Videos">üîÑ</button>

  <!-- Firebase SDK -->
  <script type="module">
    // Import Firebase modules
   import { 
    initializeApp 
  } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';

  import { 
    getFirestore, 
    collection, 
    addDoc, 
    getDocs, 
    onSnapshot, 
    query, 
    orderBy, 
    deleteDoc, 
    doc, 
    where, 
    setDoc, 
    serverTimestamp, 
    Timestamp,
    writeBatch  // <-- include this here
  } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

  import { 
    getAuth, 
    signInAnonymously, 
    onAuthStateChanged 
  } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
import {
  getStorage,
  ref,
  uploadBytesResumable,
  getDownloadURL,
  deleteObject
} from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC9ck4UFiLC8JRyUHonTszDd38CWnbIEZs",
      authDomain: "vanish-22814.firebaseapp.com",
      projectId: "vanish-22814",
      storageBucket: "vanish-22814.firebasestorage.app",
      messagingSenderId: "631925934112",
      appId: "1:631925934112:web:fcd0dbe49dbeb6eee69445",
      measurementId: "G-MKTXH9N4XT"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
const storage = getStorage(app);

    console.log('üöÄ Firebase initialized successfully!');
    
 window.deleteAllVideos = async function deleteAllVideos() {
  if (!confirm("Are you sure you want to delete ALL videos?")) return;

  try {
    const videosCol = collection(db, "videos");
    const videosSnapshot = await getDocs(videosCol);

    const batch = writeBatch(db);

    videosSnapshot.forEach((docSnap) => {
      batch.delete(doc(db, "videos", docSnap.id));
    });

    await batch.commit();
    console.log("All videos deleted!");
  } catch (error) {
    console.error("Error deleting videos:", error);
  }
};



    class VanishGlobalPlatform {
      constructor() {
        console.log('üì± Initializing VanishGlobalPlatform with Firebase Authentication...');
        
        this.videos = [];
        this.db = db;
        this.auth = auth;
        this.isConnected = false;
        this.isAuthenticated = false;
        this.currentUser = null;
        this.maxFileSize = 2.9 * 1024 * 1024; // 2.9MB to stay under 3MB limit
        this.currentBlobUrls = new Set(); // Track blob URLs for cleanup
        this.userId = null; // Will be set after authentication
        this.userDocRef = null; // Reference to user's presence document
        this.activeUsers = 0; // Current active user count
        
        try {
this.initializeElements = () => {
    console.log('üîç Finding DOM elements...');
    
    this.uploadBtn = document.getElementById('uploadBtn');
    this.fileInput = document.getElementById('fileInput');
    this.status = document.getElementById('status');
    this.titleInput = document.getElementById('titleInput');
    this.gallery = document.getElementById('gallery');
    this.videoPage = document.getElementById('videoPage');
    this.videoPlayer = document.getElementById('videoPlayer');
    this.videoTitle = document.getElementById('videoTitle');
    this.backBtn = document.getElementById('backBtn');
    this.uploadSection = document.getElementById('uploadSection');
    this.uploadProgress = document.getElementById('uploadProgress');
    this.uploadProgressBar = document.getElementById('uploadProgressBar');
    this.refreshBtn = document.getElementById('refreshBtn');
    this.totalVideos = document.getElementById('totalVideos');
    this.onlineUsers = document.getElementById('onlineUsers');
    this.timeToMidnight = document.getElementById('timeToMidnight');
    this.connectionStatus = document.getElementById('connectionStatus');
    this.securityStatus = document.getElementById('securityStatus');
    this.compressionOptions = document.getElementById('compressionOptions');
    this.qualitySlider = document.getElementById('qualitySlider');
    this.qualityValue = document.getElementById('qualityValue');
    this.countdown = document.getElementById('countdown');
    this.countdownValue = document.getElementById('countdownValue');
    
    // Remove duplicate uploadProgress assignment
    if (this.uploadProgress) {
      this.uploadProgressBar = this.uploadProgress.querySelector('.upload-progress-bar');
    }
    
    console.log('‚úÖ DOM elements initialized');
};
          this.initializeElements();
          console.log('‚úÖ Elements initialized');
          
          this.initializeEventListeners();
          console.log('‚úÖ Event listeners initialized');
          
          this.initializeAuthentication();
          console.log('‚úÖ Authentication started');
          
          this.startStatsUpdater();
          console.log('‚úÖ Stats updater started');
          
          this.startMidnightCleaner();
          console.log('‚úÖ Midnight cleaner started');
          
          console.log('üéâ Initialization complete!');
        } catch (error) {
          console.error('‚ùå Initialization failed:', error);
          this.updateConnectionStatus(false);
          this.updateSecurityStatus('error');
             }


  initializeEventListeners() {
    console.log('üéØ Setting up event listeners...');
    
    if (this.uploadBtn) {
      this.uploadBtn.addEventListener('click', (event) => {
        console.log('üî• UPLOAD BUTTON CLICKED!');
        event.preventDefault();
        this.handleUpload();
      });
    }
    
    if (this.backBtn) {
      this.backBtn.addEventListener('click', () => {
        this.showGallery();
      });
    }
    
    if (this.refreshBtn) {
      this.refreshBtn.addEventListener('click', () => {
        this.loadVideosFromFirebase();
      });
    }
    
    if (this.fileInput) {
      this.fileInput.addEventListener('change', () => {
        this.handleFileSelection();
      });
    }
    
    if (this.titleInput) {
      this.titleInput.addEventListener('input', () => {
        this.validateForm();
      });
    }

    if (this.qualitySlider) {
      this.qualitySlider.addEventListener('input', (e) => {
        if (this.qualityValue) {
          this.qualityValue.textContent = e.target.value;
        }
      });
    }
    
    console.log('‚úÖ Event listeners initialized');
  }

  // Continue with your other methods...
  async handleUpload() {
    console.log('üöÄ STARTING FIREBASE STORAGE UPLOAD!');
    
    try {
      if (!this.isAuthenticated) {
        this.showStatus('Authentication required. Please wait for authentication to complete.', 'error');
        return;
      }

      if (!this.isConnected) {
        this.showStatus('Not connected to Firebase. Please check your internet connection.', 'error');
        return;
      }

      if (!this.validateForm()) {
        this.showStatus('Please fill in all fields before uploading.', 'error');
        return;
      }

      let file = this.fileInput.files[0];
      if (!file) {
        this.showStatus('Please select a video file.', 'error');
        return;
      }

      const title = this.titleInput.value.trim();
      const quality = this.qualitySlider ? parseFloat(this.qualitySlider.value) : 0.7;

      console.log(`üì§ Starting upload: "${title}" (${(file.size/1024/1024).toFixed(2)}MB)`);
      console.log(`üë§ Authenticated user: ${this.currentUser.uid}`);
      
      this.uploadBtn.disabled = true;
      this.showProgress(5);

      // Only compress if file is very large
      const maxSize = 50 * 1024 * 1024; // 50MB threshold
      
      if (file.size > maxSize) {
        this.showStatus('üóúÔ∏è Compressing large video...', 'loading');
        this.showProgress(10);
        
        try {
          if (this.videoCompressor) {
            file = await this.videoCompressor.compressVideo(file, 25); // 25MB target
            console.log(`‚úÖ Compressed to: ${(file.size/1024/1024).toFixed(2)}MB`);
          }
          this.showProgress(30);
        } catch (compressionError) {
          console.warn('‚ö†Ô∏è Compression failed, uploading original:', compressionError.message);
          // Continue with original file
        }
      } else {
        this.showProgress(30);
      }

      // Generate thumbnail
      this.showStatus('üñºÔ∏è Generating thumbnail...', 'loading');
      const thumbnailData = await this.generateThumbnail(file);
      this.showProgress(40);

      // Upload to Firebase Storage
      await this.uploadToFirebaseStorage(file, title, thumbnailData);

    } catch (error) {
      console.error('‚ùå Upload failed:', error);
      this.showStatus(`Upload failed: ${error.message}`, 'error');
    } finally {
      this.uploadBtn.disabled = false;
    }
  }

  // You'll need to implement this method for Firebase upload
  async uploadToFirebase(file) {
    // Your existing Firebase upload logic here
    console.log('üì§ Uploading to Firebase...', file.name);
    // Implementation depends on your Firebase setup
  }

  // Helper method to show status
  showStatus(message, type) {
    console.log(`üì¢ Status: ${message}`);
    // Update your UI status element here
  }
    this.storage = storage;
}

class VideoCompressor {
  constructor() {
    this.maxFileSize = 25 * 1024 * 1024; // 25MB default max size
    this.compressionLevels = [
      { quality: 0.9, bitrate: 2500000, scale: 1.0, fps: 30 },
      { quality: 0.8, bitrate: 2000000, scale: 0.9, fps: 30 },
      { quality: 0.7, bitrate: 1500000, scale: 0.8, fps: 25 },
      { quality: 0.6, bitrate: 1200000, scale: 0.75, fps: 25 },
      { quality: 0.5, bitrate: 800000, scale: 0.7, fps: 24 },
      { quality: 0.4, bitrate: 600000, scale: 0.65, fps: 20 },
      { quality: 0.3, bitrate: 400000, scale: 0.6, fps: 20 },
      { quality: 0.2, bitrate: 300000, scale: 0.5, fps: 15 },
      { quality: 0.1, bitrate: 200000, scale: 0.4, fps: 15 }
    ];
  }

  async compressVideo(file, targetSizeMB = 25) {
    console.log(`üóúÔ∏è Starting compression for ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
    
    this.maxFileSize = targetSizeMB * 1024 * 1024;
    
    // Update UI
    this.updateProgress('Analyzing video...', 0);
    
    for (let i = 0; i < this.compressionLevels.length; i++) {
      const level = this.compressionLevels[i];
      console.log(`üìä Trying compression level ${i + 1}/${this.compressionLevels.length} (Quality: ${level.quality})`);
      
      try {
        const compressed = await this.compressWithSettings(file, level, i + 1);
        
        if (compressed.size <= this.maxFileSize) {
          console.log(`‚úÖ Success! Compressed from ${(file.size / 1024 / 1024).toFixed(2)}MB to ${(compressed.size / 1024 / 1024).toFixed(2)}MB`);
          this.updateProgress('‚úÖ Compression successful!', 100);
          return compressed;
        } else {
          console.log(`‚ö†Ô∏è Still too large: ${(compressed.size / 1024 / 1024).toFixed(2)}MB, trying next level...`);
        }
      } catch (error) {
        console.error(`‚ùå Compression level ${i + 1} failed:`, error);
        if (i === this.compressionLevels.length - 1) {
          throw error;
        }
        // Continue to next level on error
      }
    }
    
    throw new Error(`Unable to compress video below ${targetSizeMB}MB after trying all compression levels`);
  }

  async compressWithSettings(file, settings, attempt) {
    return new Promise((resolve, reject) => {
      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      video.muted = true;
      video.preload = 'metadata';
      video.crossOrigin = 'anonymous';

      const timeout = setTimeout(() => {
        URL.revokeObjectURL(video.src);
        reject(new Error('Video compression timeout - trying next level'));
      }, 90000); // 90 second timeout per level

      video.addEventListener('loadedmetadata', async () => {
        try {
          clearTimeout(timeout);
          
          // Calculate target dimensions
          const targetWidth = Math.floor(video.videoWidth * settings.scale);
          const targetHeight = Math.floor(video.videoHeight * settings.scale);
          
          // Ensure dimensions are divisible by 2 (required for most codecs)
          const evenWidth = targetWidth % 2 === 0 ? targetWidth : targetWidth - 1;
          const evenHeight = targetHeight % 2 === 0 ? targetHeight : targetHeight - 1;
          
          // Minimum size constraints
          const minWidth = Math.max(evenWidth, 240);
          const minHeight = Math.max(evenHeight, 160);
          
          console.log(`üé¨ Processing: ${video.videoWidth}x${video.videoHeight} ‚Üí ${minWidth}x${minHeight}`);
          console.log(`‚öôÔ∏è Settings: Bitrate ${settings.bitrate}, FPS ${settings.fps}`);
          
          // Create optimized canvas stream
          const stream = await this.createOptimizedStream(video, minWidth, minHeight, settings.fps);
          
          const mimeType = this.getBestMimeType();
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: mimeType,
            videoBitsPerSecond: settings.bitrate,
            audioBitsPerSecond: 64000 // Lower audio bitrate for better compression
          });

          const chunks = [];
          let startTime = Date.now();

          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
              const elapsed = (Date.now() - startTime) / 1000;
              const progress = Math.min(90, (elapsed / video.duration) * 80 + (attempt - 1) * 10);
              this.updateProgress(`Compressing (Level ${attempt})...`, progress);
            }
          };

          mediaRecorder.onstop = () => {
            const compressedBlob = new Blob(chunks, { type: mimeType });
            const extension = this.getExtensionFromMimeType(mimeType);
            
            const compressedFile = new File(
              [compressedBlob],
              file.name.replace(/\.[^/.]+$/, '') + '_compressed' + extension,
              { type: mimeType }
            );

            URL.revokeObjectURL(video.src);
            resolve(compressedFile);
          };

          mediaRecorder.onerror = (error) => {
            console.error('‚ùå MediaRecorder error:', error);
            URL.revokeObjectURL(video.src);
            reject(new Error(`MediaRecorder failed: ${error.message}`));
          };

          // Start recording with smaller data intervals for better memory management
          mediaRecorder.start(2000);
          
          // Play video
          video.currentTime = 0;
          await video.play();
          
          // Stop recording when video ends
          video.addEventListener('ended', () => {
            setTimeout(() => mediaRecorder.stop(), 100);
          });

        } catch (error) {
          clearTimeout(timeout);
          URL.revokeObjectURL(video.src);
          reject(error);
        }
      });

      video.addEventListener('error', (e) => {
        clearTimeout(timeout);
        console.error('‚ùå Video loading failed:', e);
        URL.revokeObjectURL(video.src);
        reject(new Error('Video loading failed'));
      });
    });
  }

  async createOptimizedStream(video, width, height, targetFPS) {
    // Use OffscreenCanvas for better performance
    let canvas, ctx;
    
    if (typeof OffscreenCanvas !== 'undefined') {
      canvas = new OffscreenCanvas(width, height);
      ctx = canvas.getContext('2d', { 
        alpha: false,
        desynchronized: true 
      });
    } else {
      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      ctx = canvas.getContext('2d', { alpha: false });
    }

    // Optimize canvas rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'medium'; // Balance between quality and performance

    const stream = canvas.captureStream(targetFPS);
    
    // More efficient frame drawing with frame skipping
    let lastDrawTime = 0;
    const frameInterval = 1000 / targetFPS;
    
    const drawFrame = (currentTime) => {
      if (currentTime - lastDrawTime >= frameInterval) {
        if (video.currentTime < video.duration && !video.paused && !video.ended) {
          ctx.drawImage(video, 0, 0, width, height);
          lastDrawTime = currentTime;
        }
      }
      
      if (video.currentTime < video.duration && !video.paused && !video.ended) {
        requestAnimationFrame(drawFrame);
      }
    };

    video.addEventListener('play', () => drawFrame(0));
    
    return stream;
  }

  getBestMimeType() {
    // Updated codec priority for better compression
    const codecs = [
      'video/webm;codecs=vp9,opus',     // Best compression ratio
      'video/webm;codecs=vp8,opus',     // Good compression, wide support
      'video/webm;codecs=h264,opus',    // H.264 in WebM
      'video/mp4;codecs=h264,aac',      // Fallback for maximum compatibility
      'video/webm'                      // Basic fallback
    ];

    for (const codec of codecs) {
      if (MediaRecorder.isTypeSupported(codec)) {
        console.log(`üìπ Using codec: ${codec}`);
        return codec;
      }
    }
    
    console.warn('‚ö†Ô∏è No preferred codec supported, using default');
    return 'video/webm';
  }

  getExtensionFromMimeType(mimeType) {
    if (mimeType.includes('mp4')) return '.mp4';
    if (mimeType.includes('webm')) return '.webm';
    return '.webm';
  }

  updateProgress(message, percent) {
    const countdownEl = document.getElementById('countdown');
    const countdownValue = document.getElementById('countdownValue');
    
    if (countdownEl) {
      countdownEl.style.display = 'block';
      if (countdownValue) {
        countdownValue.textContent = `${message} ${Math.round(percent)}%`;
      } else {
        countdownEl.textContent = `${message} ${Math.round(percent)}%`;
      }
    }
    
    console.log(`üìä ${message} ${Math.round(percent)}%`);
  }
}


      async initializeUserPresence() {
        if (!this.isAuthenticated || !this.currentUser) {
          console.log('‚ö†Ô∏è Cannot initialize presence - user not authenticated');
          return;
        }

        console.log('üë• Initializing user presence tracking...');
        
        try {
          // Create user presence document using authenticated user ID
          this.userDocRef = doc(this.db, 'active_users', this.currentUser.uid);
          
          await setDoc(this.userDocRef, {
            userId: this.currentUser.uid,
            lastSeen: serverTimestamp(),
            joinedAt: serverTimestamp(),
            userAgent: navigator.userAgent.substring(0, 100), // First 100 chars
            page: 'main'
          });
          
          console.log(`‚úÖ User presence created: ${this.currentUser.uid}`);
          
          // Set up real-time active users listener
          this.setupActiveUsersListener();
          
          // Update presence every 30 seconds
          this.startPresenceUpdater();
          
          // Handle page visibility changes
          this.setupVisibilityHandlers();
          
        } catch (error) {
          console.error('‚ùå Failed to initialize user presence:', error);
        }
      }

      setupActiveUsersListener() {
        if (!this.isAuthenticated) return;
        
        console.log('üëÇ Setting up active users listener...');
        
        const activeUsersRef = collection(this.db, 'active_users');
        
        onSnapshot(activeUsersRef, (snapshot) => {
          const now = new Date();
          const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000); // 5 minutes ago
          
          let activeCount = 0;
          const expiredUsers = [];
          
          snapshot.forEach((doc) => {
            const data = doc.data();
            const lastSeen = data.lastSeen?.toDate();
            
            if (lastSeen && lastSeen > fiveMinutesAgo) {
              activeCount++;
            } else {
              // Mark for cleanup
              expiredUsers.push(doc.id);
            }
          });
          
          this.activeUsers = activeCount;
          this.onlineUsers.textContent = activeCount;
          
          console.log(`üë• Active users: ${activeCount}`);
          
          // Clean up expired users (don't await to avoid blocking)
          this.cleanupExpiredUsers(expiredUsers);
          
        }, (error) => {
          console.error('‚ùå Active users listener error:', error);
          // Fallback to random number
          this.onlineUsers.textContent = Math.floor(Math.random() * 50) + 10;
        });
      }

      async cleanupExpiredUsers(expiredUserIds) {
        if (expiredUserIds.length === 0) return;
        
        console.log(`üßπ Cleaning up ${expiredUserIds.length} expired users...`);
        
        try {
          const deletePromises = expiredUserIds.map(userId => 
            deleteDoc(doc(this.db, 'active_users', userId))
          );
          
          await Promise.all(deletePromises);
          console.log(`‚úÖ Cleaned up ${expiredUserIds.length} expired users`);
          
        } catch (error) {
          console.error('‚ùå Failed to cleanup expired users:', error);
        }
      }

      startPresenceUpdater() {
        if (!this.isAuthenticated) return;
        
        // Update presence every 30 seconds
        setInterval(async () => {
          if (this.userDocRef && !document.hidden && this.isAuthenticated) {
            try {
              await setDoc(this.userDocRef, {
                lastSeen: serverTimestamp(),
                page: this.getCurrentPage()
              }, { merge: true });
              
              console.log('üíì Presence heartbeat sent');
              
            } catch (error) {
              console.error('‚ùå Failed to update presence:', error);
            }
          }
        }, 30000); // 30 seconds
      }

      setupVisibilityHandlers() {
        // Handle page visibility changes
        document.addEventListener('visibilitychange', async () => {
          if (document.hidden) {
            console.log('üëª Page hidden, user went inactive');
          } else {
            console.log('üëÄ Page visible, user became active');
            // Update presence when user comes back
            if (this.userDocRef && this.isAuthenticated) {
              try {
                await setDoc(this.userDocRef, {
                  lastSeen: serverTimestamp(),
                  page: this.getCurrentPage()
                }, { merge: true });
              } catch (error) {
                console.error('‚ùå Failed to update presence on visibility change:', error);
              }
            }
          }
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
          if (this.userDocRef && navigator.sendBeacon && this.isAuthenticated) {
            const cleanupData = JSON.stringify({
              action: 'cleanup_user',
              userId: this.currentUser?.uid
            });
            
            navigator.sendBeacon('/cleanup', cleanupData);
          }
        });

        // Fallback cleanup using pagehide
        window.addEventListener('pagehide', async () => {
          if (this.userDocRef && this.isAuthenticated) {
            try {
              await deleteDoc(this.userDocRef);
              console.log('üëã User presence cleaned up on page unload');
            } catch (error) {
              console.log('‚ö†Ô∏è Could not cleanup presence on unload');
            }
          }
        });
      }

      getCurrentPage() {
        if (this.videoPage.style.display !== 'none') {
          return 'video';
        }
        return 'main';
      }

      async initializeFirebase() {
        if (!this.isAuthenticated) {
          console.log('‚ö†Ô∏è Cannot initialize Firebase - user not authenticated');
          return;
        }

        try {
          console.log('üî• Connecting to Firebase...');
          console.log('üåê Testing network connectivity...');
          
          // Test basic network connectivity first
          try {
            const response = await fetch('https://www.google.com/favicon.ico', { 
              mode: 'no-cors',
              cache: 'no-cache'
            });
            console.log('‚úÖ Network connectivity confirmed');
          } catch (networkError) {
            console.error('‚ùå Network connectivity issue:', networkError);
            this.updateConnectionStatus(false);
            this.showStatus('Network connection issue. Please check your internet connection.', 'error');
            return;
          }

          // Test Firebase connection with timeout
          console.log('üî• Testing Firebase connection...');
          const testPromise = this.testFirebaseConnection();
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Firebase connection timeout')), 15000)
          );

          await Promise.race([testPromise, timeoutPromise]);
          
          // Test connection by getting videos
          await this.loadVideosFromFirebase();
          
          // Set up real-time listener
          this.setupRealtimeListener();
          
          this.updateConnectionStatus(true);
          console.log('‚úÖ Firebase connected successfully!');
          
        } catch (error) {
          console.error('‚ùå Firebase connection failed:', error);
          this.updateConnectionStatus(false);
          
          if (error.message.includes('timeout')) {
            this.showStatus('Firebase connection timeout. Please refresh the page and try again.', 'error');
          } else if (error.code === 'permission-denied') {
            this.showStatus('Permission denied. Firebase security rules may be blocking access.', 'error');
          } else if (error.code === 'unavailable') {
            this.showStatus('Firebase service unavailable. Please try again later.', 'error');
          } else {
            this.showStatus(`Failed to connect to Firebase: ${error.message}. Please refresh and try again.`, 'error');
          }

          this.showFailsafeOptions();
        }
      }

      async testFirebaseConnection() {
        console.log('üß™ Testing Firebase read permissions...');
        
        try {
          // Try to read from videos collection (should work even if empty)
          const videosRef = collection(this.db, 'videos');
          const testQuery = query(videosRef);
          await getDocs(testQuery);
          console.log('‚úÖ Firebase read test successful');
          
          // Try to write to active_users (test write permissions)
          console.log('üß™ Testing Firebase write permissions...');
          const testUserId = 'test_' + Date.now();
          const testUserRef = doc(this.db, 'active_users', this.currentUser.uid + '_test');
          await setDoc(testUserRef, {
            test: true,
            timestamp: serverTimestamp(),
            owner: this.currentUser.uid
          });
          
          // Clean up test document
          await deleteDoc(testUserRef);
          console.log('‚úÖ Firebase write test successful');
          
        } catch (error) {
          console.error('‚ùå Firebase connection test failed:', error);
          throw error;
        }
      }

      showFailsafeOptions() {
        console.log('üÜò Showing failsafe options...');
        
        this.gallery.innerHTML = `
          <div class="empty-gallery">
            <h3 style="color: #fc8181; margin-bottom: 1rem;">üî• Firebase Connection Failed</h3>
            <p>Unable to connect to the video database.</p>
            <br>
            <button onclick="location.reload()" style="
              background: linear-gradient(45deg, #a15fcc, #d3c0f9);
              color: #1e1e2f;
              border: none;
              padding: 1rem 2rem;
              border-radius: 12px;
              font-weight: bold;
              cursor: pointer;
              margin: 0.5rem;
            ">üîÑ Retry Connection</button>
            <br><br>
            <details style="text-align: left; max-width: 600px; margin: 0 auto;">
              <summary style="cursor: pointer; color: #a15fcc; margin-bottom: 1rem;">üîß Troubleshooting Steps</summary>
              <div style="background: rgba(46, 46, 68, 0.6); padding: 1rem; border-radius: 8px; font-size: 0.9rem;">
                <p><strong>Try these steps:</strong></p>
                <ol style="text-align: left; padding-left: 1.5rem;">
                  <li>Refresh the page (Ctrl+F5 or Cmd+Shift+R)</li>
                  <li>Check your internet connection</li>
                  <li>Disable ad blockers or browser extensions</li>
                  <li>Try a different browser or incognito mode</li>
                  <li>Check if your firewall/network blocks Firebase</li>
                  <li>Clear browser cache and cookies</li>
                </ol>
                <p style="margin-top: 1rem;"><strong>Firebase Domains to Whitelist:</strong></p>
                <ul style="text-align: left; padding-left: 1.5rem; font-family: monospace; font-size: 0.8rem;">
                  <li>*.googleapis.com</li>
                  <li>*.gstatic.com</li>
                  <li>vanish-22814.firebaseapp.com</li>
                  <li>firestore.googleapis.com</li>
                </ul>
              </div>
            </details>
          </div>
        `;
      }

      setupRealtimeListener() {
        if (!this.isAuthenticated) return;
        
        console.log('üëÇ Setting up real-time listener...');
        
        const videosRef = collection(this.db, 'videos');
        const q = query(videosRef, orderBy('uploadTime', 'desc'));
        
        onSnapshot(q, (snapshot) => {
          console.log('üîÑ Real-time update received');
          console.log(`üìä Snapshot size: ${snapshot.size} documents`);
          
          this.videos = [];
          
          snapshot.forEach((doc) => {
            const data = doc.data();
            this.videos.push({
              id: doc.id,
              ...data
            });
          });
          
          this.renderGallery();
          console.log(`üìä Loaded ${this.videos.length} videos from real-time update`);
        }, (error) => {
          console.error('‚ùå Real-time listener error:', error);
          console.error('‚ùå Listener error details:', {
            code: error.code,
            message: error.message
          });
          
          this.updateConnectionStatus(false);
          
          if (error.code === 'permission-denied') {
            this.showStatus('Real-time updates blocked. Check Firebase security rules.', 'error');
          } else {
            this.showStatus(`Real-time connection lost: ${error.message}`, 'error');
          }
        });
      }

      async loadVideosFromFirebase() {
        if (!this.isAuthenticated) {
          console.log('‚ö†Ô∏è Cannot load videos - user not authenticated');
          return;
        }

        try {
          console.log('üì• Loading videos from Firebase...');
          console.log(`üîó Connecting to project: vanish-22814`);
          
          const videosRef = collection(this.db, 'videos');
          const q = query(videosRef, orderBy('uploadTime', 'desc'));
          
          console.log('üì° Executing Firestore query...');
          const querySnapshot = await getDocs(q);
          
          this.videos = [];
          let videoCount = 0;
          
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            this.videos.push({
              id: doc.id,
              ...data
            });
            videoCount++;
          });
          
          console.log(`üìä Successfully loaded ${videoCount} videos from Firebase`);
          console.log(`üìã Video IDs: ${this.videos.map(v => v.id).join(', ')}`);
          
          this.renderGallery();
          
        } catch (error) {
          console.error('‚ùå Failed to load videos:', error);
          console.error('‚ùå Error details:', {
            code: error.code,
            message: error.message,
            stack: error.stack
          });
          
          this.updateConnectionStatus(false);
          
          if (error.code === 'permission-denied') {
            console.error('üö´ Permission denied - check Firebase security rules');
            this.showStatus('Permission denied accessing videos. Firebase security rules may need updating.', 'error');
          } else if (error.code === 'unavailable') {
            console.error('üì° Firebase service unavailable');
            this.showStatus('Firebase service temporarily unavailable. Please try again.', 'error');
          } else if (error.message.includes('network')) {
            console.error('üåê Network connectivity issue');
            this.showStatus('Network error. Check your internet connection and firewall settings.', 'error');
          } else {
            this.showStatus(`Database error: ${error.message}`, 'error');
          }
          
          throw error;
        }
      }

      updateConnectionStatus(connected) {
        this.isConnected = connected;
        
        if (connected) {
          this.connectionStatus.className = 'connection-status connected';
          this.connectionStatus.textContent = 'üü¢ Connected to Servers';
        } else {
          this.connectionStatus.className = 'connection-status disconnected';
          this.connectionStatus.textContent = 'üî¥ Firebase Disconnected';
        }
      }

      validateForm() {
        const hasTitle = this.titleInput.value.trim().length > 0;
        const hasFile = this.fileInput.files.length > 0;
        
        this.uploadBtn.disabled = !hasTitle || !hasFile || !this.isConnected || !this.isAuthenticated;
        return hasTitle && hasFile && this.isConnected && this.isAuthenticated;
      }

     async handleUpload() {
  console.log('üöÄ STARTING FIREBASE STORAGE UPLOAD!');
  
  try {
    if (!this.isAuthenticated) {
      this.showStatus('Authentication required. Please wait for authentication to complete.', 'error');
      return;
    }

    if (!this.isConnected) {
      this.showStatus('Not connected to Firebase. Please check your internet connection.', 'error');
      return;
    }

    if (!this.validateForm()) {
      this.showStatus('Please fill in all fields before uploading.', 'error');
      return;
    }

    let file = this.fileInput.files[0];
    const title = this.titleInput.value.trim();
    const quality = parseFloat(this.qualitySlider.value);

    console.log(`üì§ Starting upload: "${title}" (${(file.size/1024/1024).toFixed(2)}MB)`);
    console.log(`üë§ Authenticated user: ${this.currentUser.uid}`);
    
    this.uploadBtn.disabled = true;
    this.showProgress(5);

    // Only compress if file is really large (over 100MB)
    const maxReasonableSize = 100 * 1024 * 1024; // 100MB - Firebase Storage can handle this
    
    if (file.size > maxReasonableSize) {
      this.showStatus('üóúÔ∏è Large file detected, compressing...', 'loading');
      this.showProgress(10);
      
      try {
        file = await this.quickCompress(file, quality);
        console.log(`‚úÖ Compressed: ${(file.size/1024/1024).toFixed(2)}MB`);
        this.showProgress(30);
      } catch (compressionError) {
        console.warn('‚ö†Ô∏è Compression failed, uploading original file:', compressionError.message);
        // Continue with original file - Firebase Storage can usually handle it
      }
    } else {
      console.log('‚úÖ File size acceptable, no compression needed');
      this.showProgress(30);
    }

    // Generate thumbnail first
    this.showStatus('üñºÔ∏è Generating thumbnail...', 'loading');
    const thumbnailData = await this.generateThumbnail(file);
    this.showProgress(40);

    // Upload to Firebase Storage (not Firestore!)
    await this.uploadToFirebaseStorage(file, title, thumbnailData);

  } catch (error) {
    console.error('‚ùå Upload failed:', error);
    this.showStatus(`Upload failed: ${error.message}`, 'error');
  } finally {
    this.uploadBtn.disabled = false;
  }
}

async uploadToFirebaseStorage(file, title, thumbnailData) {
  try {
    console.log('üì§ Uploading to Firebase Storage...');
    
    // Create unique file name
    const timestamp = Date.now();
    const fileName = `${timestamp}_${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
    
    // Create storage reference
    const storageRef = ref(this.storage, `videos/${this.currentUser.uid}/${fileName}`);
    
    this.showStatus('üì§ Uploading video file...', 'loading');
    this.showProgress(50);

    // Upload with progress tracking
    const uploadTask = uploadBytesResumable(storageRef, file);

    return new Promise((resolve, reject) => {
      uploadTask.on(
        'state_changed',
        (snapshot) => {
          // Progress tracking
          const progress = 50 + (snapshot.bytesTransferred / snapshot.totalBytes) * 40; // 50-90%
          this.showProgress(Math.round(progress));
          
          const percent = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          this.showStatus(`üì§ Uploading: ${Math.round(percent)}%`, 'loading');
          console.log(`Upload progress: ${Math.round(percent)}%`);
        },
        (error) => {
          console.error('‚ùå Storage upload error:', error);
          reject(error);
        },
        async () => {
          try {
            console.log('‚úÖ File uploaded to Storage successfully!');
            
            // Get download URL
            const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
            console.log('üì• Download URL obtained:', downloadURL);
            
            this.showStatus('üíæ Saving video metadata...', 'loading');
            this.showProgress(95);
            
            // Save metadata to Firestore (just metadata, not the video data!)
            const videoData = {
              id: timestamp.toString(),
              title: title,
              downloadURL: downloadURL, // This is the key - store URL not base64!
              thumbnail: thumbnailData,
              uploadTime: new Date().toISOString(),
              size: this.formatFileSize(file.size),
              uploader: this.generateAnonymousId(),
              fileName: file.name,
              fileType: file.type,
              location: this.getRandomLocation(),
              isChunked: false,
              owner: this.currentUser.uid,
              storagePath: `videos/${this.currentUser.uid}/${fileName}` // For deletion if needed
            };

            // Add to Firestore
            await addDoc(collection(this.db, 'videos'), videoData);
            
            console.log('‚úÖ Video metadata saved to Firestore!');
            this.showProgress(100);
            
            // Success!
            this.showStatus('üéâ Video uploaded successfully!', 'success');
            
            // Clear form
            this.titleInput.value = '';
            this.fileInput.value = '';
            this.compressionOptions.style.display = 'none';
            
            // Refresh gallery
            setTimeout(() => {
              this.loadVideosFromFirebase();
              this.hideStatus();
              this.hideProgress();
            }, 2000);
            
            resolve(downloadURL);
            
          } catch (metadataError) {
            console.error('‚ùå Failed to save metadata:', metadataError);
            reject(metadataError);
          }
        }
      );
    });
    
  } catch (error) {
    console.error('‚ùå Firebase Storage upload failed:', error);
    throw error;
  }
}

// Quick compression method - much simpler than your current one
async quickCompress(file, quality) {
  console.log('üóúÔ∏è Quick compressing video...');
  
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.src = URL.createObjectURL(file);
    video.muted = true;
    video.preload = 'metadata';

    const timeout = setTimeout(() => {
      URL.revokeObjectURL(video.src);
      reject(new Error('Compression timeout'));
    }, 30000); // 30 second timeout

    video.addEventListener('loadedmetadata', async () => {
      try {
        clearTimeout(timeout);
        
        // Simple scaling based on quality
        const scale = quality > 0.7 ? 0.8 : quality > 0.5 ? 0.6 : 0.5;
        const width = Math.floor(video.videoWidth * scale);
        const height = Math.floor(video.videoHeight * scale);
        
        // Ensure even dimensions
        const evenWidth = width % 2 === 0 ? width : width - 1;
        const evenHeight = height % 2 === 0 ? height : height - 1;

        console.log(`üé¨ Compressing: ${video.videoWidth}x${video.videoHeight} ‚Üí ${evenWidth}x${evenHeight}`);

        const canvas = document.createElement('canvas');
        canvas.width = evenWidth;
        canvas.height = evenHeight;
        const ctx = canvas.getContext('2d');
        
        const stream = canvas.captureStream(20); // 20fps for faster processing
        
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp8,opus',
          videoBitsPerSecond: Math.floor(1000000 * quality), // Simple bitrate calculation
          audioBitsPerSecond: 64000
        });

        const chunks = [];
        
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) chunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
          const compressedBlob = new Blob(chunks, { type: 'video/webm' });
          const compressedFile = new File(
            [compressedBlob],
            file.name.replace(/\.[^/.]+$/, '') + '_compressed.webm',
            { type: 'video/webm' }
          );
          URL.revokeObjectURL(video.src);
          resolve(compressedFile);
        };

        mediaRecorder.onerror = (error) => {
          URL.revokeObjectURL(video.src);
          reject(error);
        };

        mediaRecorder.start();

        const drawFrame = () => {
          if (video.currentTime < video.duration && !video.ended) {
            ctx.drawImage(video, 0, 0, evenWidth, evenHeight);
            requestAnimationFrame(drawFrame);
          } else {
            mediaRecorder.stop();
          }
        };

        video.play().then(() => drawFrame());

      } catch (error) {
        clearTimeout(timeout);
        URL.revokeObjectURL(video.src);
        reject(error);
      }
    });

    video.addEventListener('error', (e) => {
      clearTimeout(timeout);
      URL.revokeObjectURL(video.src);
      reject(new Error('Video loading failed'));
    });
  });
}

// Updated gallery rendering to use download URLs
renderGallery() {
  if (this.videos.length === 0) {
    this.gallery.innerHTML = `
      <div class="empty-gallery">
        <p>üìπ No videos uploaded yet.</p>
        <p>Be the first to share a video</p>
      </div>
    `;
    this.totalVideos.textContent = '0';
    return;
  }

  this.gallery.innerHTML = this.videos.map((video, index) => `
    async showVideo(index) {
      console.log(`üì∫ Showing video ${index}`);
      const video = this.videos[index];
      if (!video) return;
    
      this.videoTitle.textContent = this.escapeHtml(video.title || '');
      // Clean up any old blob URLs
      if (this._lastBlobUrl) {
        URL.revokeObjectURL(this._lastBlobUrl);
        this._lastBlobUrl = null;
      }
    
      try {
        // Prefer Firebase Storage download URL (most common case)
        if (video.downloadURL) {
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          console.log('DEBUG: Setting videoPlayer.src to ->', video.downloadURL);
          this.videoPlayer.src = video.downloadURL;
        } else if (video.isChunked) {
          this.showStatus('Loading video...', 'loading');
          const videoData = await this.loadChunkedVideo(video.id);
          const blob = this.base64ToBlob(videoData);
          const url = URL.createObjectURL(blob);
          this._lastBlobUrl = url;
          this.videoPlayer.src = url;
          this.hideStatus();
        } else if (video.videoData) {
          // old-style base64-stored videos
          const blob = this.base64ToBlob(video.videoData);
          const url = URL.createObjectURL(blob);
          this._lastBlobUrl = url;
          this.videoPlayer.src = url;
          this.hideStatus();
        } else {
          throw new Error('No playable source found for this video.');
        }
    
        // Show the player UI
        if (this.gallery) this.gallery.style.display = 'none';
        if (this.uploadSection) this.uploadSection.style.display = 'none';
        if (this.videoPage) this.videoPage.style.display = 'block';
    
        // Load & attempt autoplay (graceful if blocked)
        if (this.videoPlayer) {
          this.videoPlayer.load();
          setTimeout(() => {
            this.videoPlayer.play().catch(e => {
              console.log('Auto-play prevented by browser policy');
            });
          }, 100);
        }
    
      } catch (error) {
        console.error('‚ùå Failed to load video:', error);
        if (this.showStatus) this.showStatus('Failed to load video. Please try again.', 'error');
      }
    }
      <div class="global-badge">Watch Now</div>
      <img src="${video.thumbnail}" alt="${video.title}" class="video-thumbnail" loading="lazy" />
      <div class="video-info">
        <h3 class="video-title">${this.escapeHtml(video.title)}</h3>
        <div class="video-meta">
          <span>${this.timeAgo(video.uploadTime)}</span>
          <span>${video.size}</span>
        </div>
        <div class="video-meta">
          <span>üìç ${video.location || 'Unknown'}</span>
          <span>üë§ ${video.uploader}</span>
        </div>
      </div>
    </div>
  `).join('');

  this.totalVideos.textContent = this.videos.length;
  console.log(`‚úÖ Gallery rendered with ${this.videos.length} videos`);
}

// Updated video display method

    }
        this.gallery.style.display = 'none';
        this.uploadSection.style.display = 'none';
        this.videoPage.style.display = 'block';
        
        setTimeout(() => {
          this.videoPlayer.play().catch(e => {
            console.log('Auto-play prevented by browser policy');
          });
        }, 100);
      }

      base64ToBlob(base64Data) {
        console.log('üîÑ Converting base64 to blob URL...');
        
        try {
          // Remove data URL prefix if present
          const base64String = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;
          const mimeType = base64Data.includes(',') ? base64Data.split(',')[0].split(':')[1].split(';')[0] : 'video/mp4';
          
          // Convert base64 to binary
          const byteCharacters = atob(base64String);
          const byteNumbers = new Array(byteCharacters.length);
          
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          
          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: mimeType });
          
          // Create blob URL
          const blobUrl = URL.createObjectURL(blob);
          this.currentBlobUrls.add(blobUrl);
          
          console.log(`‚úÖ Created blob URL: ${blobUrl.substring(0, 50)}...`);
          return blobUrl;
          
        } catch (error) {
          console.error('‚ùå Failed to convert base64 to blob:', error);
          // Fallback to direct base64
          return base64Data;
        }
      }

      cleanupBlobUrls() {
        console.log('üßπ Cleaning up blob URLs...');
        this.currentBlobUrls.forEach(url => {
          URL.revokeObjectURL(url);
        });
        this.currentBlobUrls.clear();
      }

      async loadChunkedVideo(videoId) {
        if (!this.isAuthenticated) {
          throw new Error('Authentication required to load video chunks');
        }

        console.log(`üì¶ Loading chunks for video ${videoId}...`);
        
        try {
          // Get all chunks for this video - use only where clause to avoid index requirement
          const chunksRef = collection(this.db, 'video_chunks');
          const q = query(chunksRef, where('videoId', '==', videoId));
          const querySnapshot = await getDocs(q);
          
          const chunks = [];
          querySnapshot.forEach((doc) => {
            const data = doc.data();
            chunks[data.chunkIndex] = data.chunkData;
          });
          
          console.log(`üì¶ Loaded ${chunks.length} chunks`);
          
          // Sort chunks by index (since we can't use orderBy)
          const sortedChunks = [];
          for (let i = 0; i < chunks.length; i++) {
            if (chunks[i] !== undefined) {
              sortedChunks.push(chunks[i]);
            }
          }
          
          // Combine all chunks
          const completeVideoData = sortedChunks.join('');
          
          // Find the original base64 prefix from the first chunk
          const firstChunk = sortedChunks[0];
          if (firstChunk && firstChunk.startsWith('data:')) {
            const prefixEnd = firstChunk.indexOf(',') + 1;
            const prefix = firstChunk.substring(0, prefixEnd);
            return prefix + sortedChunks.join('').substring(prefixEnd);
          }
          
          return completeVideoData;
          
        } catch (error) {
          console.error('‚ùå Failed to load video chunks:', error);
          throw error;
        }
      }

      showGallery() {
        console.log('üè† Showing gallery');
        this.videoPlayer.pause();
        this.videoPlayer.src = '';
        // Clean up blob URLs when leaving video page
        this.cleanupBlobUrls();
        
        this.videoPage.style.display = 'none';
        this.gallery.style.display = 'grid';
        this.uploadSection.style.display = 'block';
        
        this.hideStatus();
      }

      startStatsUpdater() {
        this.updateStats();
        setInterval(() => this.updateStats(), 30000);
      }

      updateStats() {
        // Calculate time until midnight CST
        const now = new Date();
        const cstOffset = -6 * 60; // CST is UTC-6
        const nowCST = new Date(now.getTime() + (now.getTimezoneOffset() + cstOffset) * 60 * 1000);
        
        const tomorrow = new Date(nowCST);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);
        
        const timeUntilMidnight = tomorrow - nowCST;
        const hours = Math.floor(timeUntilMidnight / (1000 * 60 * 60));
        const minutes = Math.floor((timeUntilMidnight % (1000 * 60 * 60)) / (1000 * 60));
        
        this.timeToMidnight.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
      }

      startMidnightCleaner() {
        console.log('üïõ Starting midnight cleaner...');

        // Track the last date videos were deleted
        let lastDeletedDate = null;

        setInterval(async () => {
          const now = new Date();
          const cstOffset = -6 * 60; // CST is UTC-6
          const nowCST = new Date(now.getTime() + (now.getTimezoneOffset() + cstOffset) * 60 * 1000);

          const hours = nowCST.getHours();
          const minutes = nowCST.getMinutes();
          const currentDateStr = nowCST.toISOString().slice(0, 10); // YYYY-MM-DD

          // Delete once per day, during 00:00-00:04 CST
          if (hours === 0 && minutes < 5 && lastDeletedDate !== currentDateStr) {
            console.log('üïõ MIDNIGHT CST! Deleting all videos...');
            lastDeletedDate = currentDateStr;
            await this.deleteAllVideos();
          }

        }, 60000); // Check every minute
      }

      async deleteAllVideos() {
        if (!this.isAuthenticated) {
          console.log('‚ö†Ô∏è Cannot delete videos - user not authenticated');
          return;
        }

        try {
          console.log('üóëÔ∏è Deleting all videos from Firebase...');
          this.showStatus('üïõ Midnight reset! Deleting all videos...', 'loading');
          
          const deletePromises = [];

          // Delete all videos
          const videosSnapshot = await getDocs(collection(this.db, 'videos'));
          videosSnapshot.forEach((doc) => deletePromises.push(deleteDoc(doc.ref)));

          // Delete all video chunks
          const chunksSnapshot = await getDocs(collection(this.db, 'video_chunks'));
          chunksSnapshot.forEach((doc) => deletePromises.push(deleteDoc(doc.ref)));

          // Delete all active users
          const activeUsersSnapshot = await getDocs(collection(this.db, 'active_users'));
          activeUsersSnapshot.forEach((doc) => deletePromises.push(deleteDoc(doc.ref)));

          await Promise.all(deletePromises);

          console.log('‚úÖ All videos, chunks, and user sessions deleted successfully!');
          this.showStatus('üåÖ Fresh start! All videos have been deleted at midnight CST.', 'success');

          setTimeout(() => this.hideStatus(), 5000);

        } catch (error) {
          console.error('‚ùå Failed to delete videos:', error);
          this.showStatus('Failed to delete videos. Please refresh the page.', 'error');
        }
      }

      generateAnonymousId() {
        return 'anon_' + Math.random().toString(36).substr(2, 6);
      }

      getRandomLocation() {
        const locations = [
          'Kansas'
        ];
        return locations[Math.floor(Math.random() * locations.length)];
      }

      showStatus(message, type) {
        this.status.textContent = message;
        this.status.className = `status ${type}`;
        this.status.style.display = 'block';
      }

      hideStatus() {
        this.status.style.display = 'none';
      }

      showProgress(percent) {
        this.uploadProgress.style.display = 'block';
        this.uploadProgressBar.style.width = percent + '%';
      }

      hideProgress() {
        this.uploadProgress.style.display = 'none';
        this.uploadProgressBar.style.width = '0%';
      }

      formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      timeAgo(dateString) {
        const now = new Date();
        const past = new Date(dateString);
        const diffInMinutes = Math.floor((now - past) / (1000 * 60));
        
        if (diffInMinutes < 1) return 'Just now';
        if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
        if (diffInMinutes < 1440) return `${Math.floor(diffInMinutes / 60)}h ago`;
        return `${Math.floor(diffInMinutes / 1440)}d ago`;
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
    }

    // Initialize the app and make it globally accessible
    window.vanishApp = new VanishGlobalPlatform();
  </script>

</body></html>
